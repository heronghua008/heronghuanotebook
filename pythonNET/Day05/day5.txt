前情回顾

1. poll   epoll（效率较高）
2. 本地套接字 ： AF_UNIX  本地两个进程间的通信
3. 多任务编程  
     并行，并发
     什么是进程
     进程的状态
4. 创建进程 os.fork()

*************************************************

进程相关函数使用

os.getpid()
功能 ： 获取当前进程的PID号
返回值 ： 返回PID号

os.getppid()
功能 ： 获取父进程的进程号
返回值 ： 返回PID号

os._exit(status)
功能 ： 退出进程
参数 ： 进程的退出状态  整数

sys.exit([status])
功能： 退出进程
参数： 默认为0  如果是整数则表示退出状态
                如果是字符串则表示退出时打印内容

* sys.exit 可以通过捕获SystemExit异常阻止退出

孤儿进程 ： 父进程先于子进程退出，此时子进程就会成             为孤儿进程。

* 孤儿进程会被系统指定的进程收养，即系统进程会成为   该孤儿进程新的父进程。孤儿进程退出时该父进程会处   理退出状态

僵尸进程 ： 子进程先于父进程退出，父进程没有处理子             进程退出状态，此时子进程成为僵尸进程

* 僵尸进程已经结束，但是会滞留部分PCB信息在内存，大量的僵尸会消耗系统资源，应该尽量避免

如何避免僵尸进程产生

* 父进程处理子进程退出状态
 
  pid,status = os.wait()
  功能 ：在父进程中阻塞等待处理子进程的退出
  返回值 ： pid  退出的子进程的PID号
            status  子进程的退出状态 
  
  pid,status = os.waitpid(pid,option)
  功能 ： 同wait
  参数 ： pid   -1  表示任意子进程退出
                >0  整数  指定PID号的子进程退出
	option   0  表示阻塞等待
	       WNOHANG  表示非阻塞
  返回值 ： 同wait

  waitpid(-1,0)   ======  wait()

* 父进程先退出
  创建二级子进程 
    1. 父进程创建子进程等待子进程退出
    2. 子进程创建二级子进程，然后马上退出
    3. 二级子进程成为孤儿，处理具体事件


写一个聊天室

功能 ： 类似qq群聊
1. 进入聊天室需要输入用户名
2. 有人进入聊天室 其他人会收到提示
   xxx 进入聊天室
3. 某人发消息，则其他人都能收到
   xxx 说： xxxxxxxxx
4. 有人退出聊天室 其他人会收到提示
   xxx 退出了聊天室
5. 管理员功能，管理员喊话聊天室所有人都能收到

 服务端  客户端
 * 整体实现方案
 * 用什么技术

1. 用什么技术
  
  socket通信   ----> 消息转发 ----》 UDP通信
  
  转发模式 --->  每个将消息发送给服务器，服务器发                送个每个成员
  
  消息收发  ---> 使用多进程让发送和接受互不影响
 
  存储用户  --->  字典 或者 列表 
                  姓名，地址

注意 ： 使用一定的封装性
        测试 ， 每个功能进行测试

代码编写

先搭建网络连接 --》 多进程创建 --》每个功能编写--
》功能测试

客户端
  * 登录   "L name" 
    服务器 ： 识别请求 判断是否可以登录
              保留用户
	      将登录消息通知其他人

  * 聊天   "C name message"
    服务器 ： 识别请求
              将消息转发给其他人

  * 退出   "Q name"
    服务器 ： 识别请求
              告知其他人退出
	      从结构中删除用户

服务器
 
  
multiprocessing 模块创建进程

1. 需要将要做的事件封装为函数
2. 使用multiprocessing中提供的Process类创建进程对    象
3.通过进程对象和Process 初始化函数 对进程进行设置，并且绑定要执行的事件
4. 启动进程，会自动执行相关联函数
5. 事件完成后回收进程

创建进程对象

Process()
功能 ： 创建进程对象
参数 ： name :  给创建的进程起一个名字
                默认Process-1
	target : 绑定的函数

	args ： 元组 给target函数按照位置传参
	kwargs ： 字典 给target函数按照键值出传参
 
p.start()
功能： 启动进程，此时进程被创建。自动运行进程函数

p.join([timeout])
功能 ： 阻塞等待回收响应的进程
参数 ： 超时时间

* multiprocessing创建进程是原来进程的子进程，创建后父子进程各自执行互不影响
* 子进程同样是复制父进程的空间，子进程对内容的修改不会影响父进程空间
* join回收子进程，会有效的阻止僵尸进程产生

作业 ： multipeocessing  对照fork
        
	创建父子进程，复制一个文件，父子进程各复制一半到一个新的文件中







